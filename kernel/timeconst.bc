scale = 0

define gcd(a, b)
{
	auto t;

	while (b) {
		t = b;
		b = a % b;
		a = t;
	}

	return a;
}

/*
 * Adjustment factor when a ceiling value is used.
 * Use as: imul * n + ((fmulxx * n + fadjxx) >> xx).
 */
define fadj(b, n, d)
{
	d /= gcd(n, d);
	return (2 ^ b * (d - 1)) / d;
}

/* Division by reciprocal multiplication */
define fmul(b, n, d)
{
       return (2 ^ b * n + (d - 1)) / d;
}

/*
 * Compute the appropriate mul/adj values as well as a shift count, which
 * brings the mul value into the range [2 ^ 31; 2 ^ 32) (integer). Such a shift
 * value will be correct in the signed integer range and off by at most one in
 * the upper half of the unsigned range.
 */
define fmuls(n, d)
{
	auto b;

	for (b = 0;; b++)
		if (fmul(b, n, d) >= 2147483648)
			return b;

	return 0;
}

/* timeconst(hz) main code */
print "/*\n"
print " * Automatically generated by kernel/timeconst.bc\n"
print " * Time conversion constants for HZ == ", hz, "\n"
print " */\n\n"

print "#ifndef __KERNEL_TIMECONST_H__\n"
print "#define __KERNEL_TIMECONST_H__\n\n"

print "#include <linux/param.h>\n"
print "#include <linux/types.h>\n\n"

print "#if (HZ != ", hz, ")\n"
print "#error \qkernel/timeconst.h has the wrong HZ value!\q\n"
print "#endif\n\n"

if (hz < 2) {
	print "#error Totally bogus HZ value!\n\n"
	print "#endif /* __KERNEL_TIMECONST_H__ */"
	halt
}

b = fmuls(1000, hz)
obase = 16
print "#define HZ_TO_MSEC_MUL32\tU64_C(0x", fmul(b, 1000, hz), ")\n"
print "#define HZ_TO_MSEC_ADJ32\tU64_C(0x", fadj(b, 1000, hz), ")\n"
obase = 10
print "#define HZ_TO_MSEC_SHR32\t(", b, ")\n"

b = fmuls(hz, 1000)
obase = 16
print "#define MSEC_TO_HZ_MUL32\tU64_C(0x", fmul(b, hz, 1000), ")\n"
print "#define MSEC_TO_HZ_ADJ32\tU64_C(0x", fadj(b, hz, 1000), ")\n"
obase = 10
print "#define MSEC_TO_HZ_SHR32\t(", b, ")\n"

cd = gcd(hz, 1000)
print "#define HZ_TO_MSEC_NUM\t\t(", 1000 / cd, ")\n"
print "#define HZ_TO_MSEC_DEN\t\t(", hz / cd, ")\n"
print "#define MSEC_TO_HZ_NUM\t\t(", hz / cd, ")\n"
print "#define MSEC_TO_HZ_DEN\t\t(", 1000 / cd, ")\n\n"

b = fmuls(1000000, hz)
obase = 16
print "#define HZ_TO_USEC_MUL32\tU64_C(0x", fmul(b, 1000000, hz), ")\n"
print "#define HZ_TO_USEC_ADJ32\tU64_C(0x", fadj(b, 1000000, hz), ")\n"
obase = 10
print "#define HZ_TO_USEC_SHR32\t(", b, ")\n"

b = fmuls(hz, 1000000)
obase = 16
print "#define USEC_TO_HZ_MUL32\tU64_C(0x", fmul(b, hz, 1000000), ")\n"
print "#define USEC_TO_HZ_ADJ32\tU64_C(0x", fadj(b, hz, 1000000), ")\n"
obase = 10
print "#define USEC_TO_HZ_SHR32\t(", b, ")\n"

cd = gcd(hz, 1000000)
print "#define HZ_TO_USEC_NUM\t\t(", 1000000 / cd, ")\n"
print "#define HZ_TO_USEC_DEN\t\t(", hz / cd, ")\n"
print "#define USEC_TO_HZ_NUM\t\t(", hz / cd, ")\n"
print "#define USEC_TO_HZ_DEN\t\t(", 1000000 / cd, ")\n\n"

print "#endif /* __KERNEL_TIMECONST_H__ */"
quit
